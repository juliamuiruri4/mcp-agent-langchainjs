{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "4 - Building the Agent API",
  "description": "Integrate MCP tools with LangChain agents. Learn streaming, event processing, and chat history management.",
  "nextTour": "5 - Backend API Design",
  "steps": [
    {
      "title": "Agent API Architecture",
      "description": "## The Agent API: Orchestrating Everything ğŸ­\n\n### Bringing It All Together - Where LangChain.js meets MCP\n\nThe Agent API is the **orchestration layer** that connects:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ User Request â”‚  \"Order a cheeseburger\"\nâ””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜\n       â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚          AGENT API (this tour!)              â”‚\nâ”‚                                              â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚  â”‚  LLM   â”‚â†â†’â”‚ MCP Toolsâ”‚â†â†’â”‚ Chat Historyâ”‚   â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                   â†“\n           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n           â”‚ Streaming     â”‚  \"Let me help...\"\n           â”‚ JSON Response â”‚  [tool: get_burgers]\n           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  \"Order placed!\"\n```\n\n---\n\n### What We'll Learn\n\n1. **MCP Client Connection** - How the agent connects to tools\n2. **Loading Tools** - Converting MCP tools to LangChain format\n3. **Creating the Agent** - Combining model + tools + prompt\n4. **Streaming Architecture** - Real-time response delivery\n5. **Event Processing** - Transforming LangChain events to JSON\n6. **State Management** - Sessions, history, and context (CosmosDB)\n\n---\n\n### The Request Lifecycle\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  ğŸ“¥ Request                                                 â”‚\nâ”‚      â†“                                                      â”‚\nâ”‚  âœ… Validate (auth, params)                                 â”‚\nâ”‚      â†“                                                      â”‚\nâ”‚  ğŸ”Œ Connect to MCP Server                                   â”‚\nâ”‚      â†“                                                      â”‚\nâ”‚  ğŸ”§ Load Tools from MCP                                     â”‚\nâ”‚      â†“                                                      â”‚\nâ”‚  ğŸ¤– Create Agent (model + tools + prompt)                   â”‚\nâ”‚      â†“                                                      â”‚\nâ”‚  ğŸ“¡ Stream Response Events                                  â”‚\nâ”‚      â†“                                                      â”‚\nâ”‚  ğŸ“¤ Return NDJSON Stream                                    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```"
    },
    {
      "file": "packages/agent-api/src/functions/chats-post.ts",
      "line": 100,
      "selection": {
        "start": {
          "line": 100,
          "character": 5
        },
        "end": {
          "line": 110,
          "character": 35
        }
      },
      "title": "Connecting to MCP Server",
      "description": "## Connecting to the MCP Server ğŸ”Œ\n\nHere's how we establish a connection to the MCP server:\n\n```typescript\nconst client = new Client({\n  name: 'burger-mcp-client',\n  version: '1.0.0',\n});\n\n...\n```\n\n---\n\n### MCP Client Configuration\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. Create Client                                           â”‚\nâ”‚     â””â†’ Identity for this MCP client                         â”‚\nâ”‚                                                             â”‚\nâ”‚  2. Create Transport                                        â”‚\nâ”‚     â””â†’ HTTP transport to MCP server URL                     â”‚\nâ”‚                                                             â”‚\nâ”‚  3. Connect                                                 â”‚\nâ”‚     â””â†’ Establish the connection                             â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\nThe `burgerMcpUrl` comes from environment variables. This makes it easy to switch between:\n- `http://localhost:7071/mcp` (local development)\n- `https://burger-mcp.azurewebsites.net/mcp` (production)\n\n---\n\n### Loading Tools into LangChain\n\n```typescript\nconst tools = await loadMcpTools('burger', client);\ncontext.log(`Loaded ${tools.length} tools from Burger MCP server`);\n```\n\n### What loadMcpTools Does\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. Query MCP server for available tools                    â”‚\nâ”‚      â†“                                                      â”‚\nâ”‚  2. Convert MCP tool definitions to LangChain format        â”‚\nâ”‚      â†“                                                      â”‚\nâ”‚  3. Return array of LangChain-compatible tools              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### The Magic of MCP Adapters\n\nThe `@langchain/mcp-adapters` package handles:\n- âœ… Tool discovery (asks MCP: \"What can you do?\")\n- âœ… Schema conversion (MCP â†’ LangChain)\n- âœ… Invocation routing (LangChain â†’ MCP â†’ API)\n\n**Any MCP server works with LangChain!** No custom integration needed.\n\nTools are loaded **at request time**, so:\n- New tools appear automatically\n- No agent restart needed\n- Different users could have different tools"
    },
    {
      "file": "packages/agent-api/src/functions/chats-post.ts",
      "line": 122,
      "selection": {
        "start": {
          "line": 122,
          "character": 5
        },
        "end": {
          "line": 129,
          "character": 7
        }
      },
      "title": "Streaming Agent Execution",
      "description": "## Streaming the Agent's Thought Process ğŸŒŠ\n\nThis is where the magic happens - **streaming agent execution**:\n\n### Message Construction\n\n```typescript\nmessages: [\n  ['human', `userId: ${userId}`],     // â† User context\n  ...previousMessages,                // â† Chat history\n  ['human', question]                 // â† Current question\n]\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Message 1: userId context                                  â”‚\nâ”‚  â””â†’ \"userId: user-123\" (injected for tools)                 â”‚\nâ”‚                                                             â”‚\nâ”‚  Messages 2-N: previousMessages                             â”‚\nâ”‚  â””â†’ Chat history from Cosmos DB                             â”‚\nâ”‚                                                             â”‚\nâ”‚  Final Message: question                                    â”‚\nâ”‚  â””â†’ The current user question                               â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Why include userId as a message?**\n\nRemember the system prompt:\n```markdown\n## Instructions\n- Never expose the userId to the user.\n```\n\nBut the agent **needs** userId to:\n- Call `get_orders({ userId: \"...\" })`\n- Call `place_order({ userId: \"...\", ... })`\n\nSo we inject it as a **hidden context message**!\n\n---\n\n###  Why streamEvents()?\n\nLangChain emits **many event types** during execution:\n\n```typescript\n'on_chat_model_stream'   // â† LLM generating text\n'on_chat_model_end'      // â† LLM finished\n'on_tool_start'          // â† About to call tool\n'on_tool_end'            // â† Tool call complete\n'on_agent_action'        // â† Agent decided action\n'on_agent_finish'        // â† Agent done\n```\n\n**Each event has**:\n- `event` - Type of event\n- `name` - Name of component (tool name, model name)\n- `data` - Payload (input, output, chunk, etc.)\n- `metadata` - Additional context\n\n**We filter these** in `createJsonStream` to only send relevant events to frontend.\n\n**Benefits**:\n1. User sees progress immediately\n2. Can show tool calls in real-time\n3. Can cancel if user navigates away\n4. Feels more interactive\n"
    },
    {
      "file": "packages/agent-api/src/functions/chats-post.ts",
      "line": 197,
      "selection": {
        "start": {
          "line": 197,
          "character": 1
        },
        "end": {
          "line": 253,
          "character": 4
        }
      },
      "title": "Transforming Events to JSON",
      "description": "## Event Processing: LangChain â†’ JSON ğŸ”„\n\nThis generator function transforms **LangChain stream events** into **JSON chunks** for the frontend:\n\n```typescript\nasync function* createJsonStream(\n  chunks: AsyncIterable<StreamEvent>,\n  sessionId: string,\n  onComplete: (responseContent: string) => Promise<void>,\n) {\n    // ...\n```\n\n---\n\n### Why Transform?\n\n**LangChain event** (internal format):\n```json\n{\n  \"event\": \"on_tool_end\",\n  \"name\": \"get_burgers\",\n  \"data\": {\n    \"output\": \"[{id: 'burger-1', name: 'Cheeseburger'}]\"\n  }\n}\n```\n\n**Transformed JSON** (frontend-friendly):\n```json\n{\n  \"delta\": {\n    \"context\": {\n      \"intermediateSteps\": [{\n        \"type\": \"tool\",\n        \"name\": \"get_burgers\",\n        \"output\": \"[{id: 'burger-1', name: 'Cheeseburger'}]\"\n      }]\n    }\n  }\n}\n```\n\n**Benefits**:\n- Frontend doesn't need to understand LangChain internals\n- Consistent format across all events\n- Can add custom fields (sessionId, metadata)\n- Easier to version and extend\n\n---\n\n### Why Use an async Generator?\n\n1. **Lazy evaluation** - Only process when client requests\n2. **Backpressure** - Slow clients won't overflow memory (Consumer controls the pace)\n3. **Early termination** - If client disconnects, stops processing\n4. **Composable** - Can chain multiple generators\n5. **Memory efficient** - Process one chunk and a time\n\n### Streaming LLM Tokens ğŸ’¬\n\n```typescript\n    responseChunk = {\n        delta: {\n        content: data.chunk.content[0].text ?? data.chunk.content,\n        role: 'assistant',\n        },\n    };\n    ...\n```\n---\n\n### What Happens Here\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ğŸ” Detect stream event from LLM                         â”‚\nâ”‚  2. ğŸ“ Extract the text token                               â”‚\nâ”‚  3. ğŸ“¦ Format as a response delta                           â”‚\nâ”‚  4. ğŸ“¤ Send to client immediately                           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\nThis is the same pattern used by OpenAI's streaming API! The client receives tokens one at a time and displays them as they arrive.\n\n### Handling Tool Events\n\n```typescript\n    ...\n    else if (chunk.event === 'on_tool_end') {\n      // Tool call completed\n      responseChunk = {\n        delta: {\n          context: {\n            intermediateSteps: [\n              {\n                type: 'tool',\n                name: chunk.name,\n                input: data?.input?.input ?? undefined,\n                output: data?.output.content ?? undefined,\n              },\n            ],\n            ...\n```\n\n### Why Track Tool Calls?\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  ğŸ” Debugging     â†’ See what tools were called              â”‚\nâ”‚  ğŸ‘ï¸ Transparency  â†’ Show users what's happening             â”‚\nâ”‚  ğŸ“Š Auditing      â†’ Log all agent actions                   â”‚\nâ”‚  ğŸ–¥ï¸ UI Feedback   â†’ \"Placing your order...\"                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\nThis creates an **audit trail** of agent reasoning. Intermediate steps are valuable for debugging when the agent makes unexpected decisions. You can trace exactly what it did and why.\n"
    },
    {
      "file": "packages/agent-api/src/functions/chats-post.ts",
      "line": 145,
      "selection": {
        "start": {
          "line": 145,
          "character": 5
        },
        "end": {
          "line": 165,
          "character": 6
        }
      },
      "title": "Updating Chat History",
      "description": "## Persisting Chat History to Cosmos DB ğŸ’¾\n\nAfter the agent finishes, we save the conversation:\n\n```typescript\nconst onResponseComplete = async (content: string) => {\n  ...\n      await sessionTitlePromise;  // â† Wait for title generation\n    }\n    ...\n```\n\n### The Two-Phase Save\n\n```\nPhase 1: Auto-Generation of chat title (parallel)\n  â†“\n  \"Create a title for this chat session...\"\n  â†’ \"Cheeseburger Order\"\n  â†“\n  chatHistory.setContext({ title: \"...\" })\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. Check if title exists â†’ Skip if already named           â”‚\nâ”‚  2. Start generation      â†’ Don't await yet!                â”‚\nâ”‚  3. Continue with stream  â†’ Response starts immediately     â”‚\nâ”‚  4. Await later           â†’ Ensure completion before cleanup â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\nNotice we don't `await` immediately. This lets the title generation run **in parallel** with the main response, reducing perceived latency.\n\nUsers see their chat named nicely: \"Bacon Burger Order\" instead of \"Chat 1\".\n\n```\nPhase 2: Save messages (after stream complete)\n  â†“\n  chatHistory.addMessages([\n    HumanMessage(\"Order a burger\"),\n    AIMessage(\"Done! Order #123\")\n  ])\n```\n\n### Why Not Save Immediately?\n\n**Problem**: If streaming fails midway:\n- History saved: âœ… \"Order a burger\"\n- User saw: âŒ Partial/broken response\n- Result: **Inconsistent state**\n\n**Good approach**:\n```typescript\nreturn stream;\n// After streaming completes\nawait chatHistory.addMessages([...]);\n```\n\n**Benefit**: Only save if **response fully generated**!"
    },
    {
      "file": "packages/agent-api/src/auth.ts",
      "line": 1,
      "selection": {
        "start": {
          "line": 1,
          "character": 1
        },
        "end": {
          "line": 30,
          "character": 2
        }
      },
      "title": "Authentication with SWA",
      "description": "## Azure Static Web Apps Authentication ğŸ”\n\nHere's how we extract the authenticated user:\n\n```typescript\nexport async function getInternalUserId(\n  request: HttpRequest,\n  requestBody?: { userId?: string },\n): Promise<string | undefined> {\n  const userIdHeader = request.headers.get('x-ms-client-principal-id');\n  \n  if (userIdHeader) {\n    return userIdHeader;  // â† SWA provides this!\n  }\n  \n  // Fallback for local dev\n  return requestBody?.userId;\n}\n```\n\n---\n\n### SWA Authentication Headers\n\nAzure Static Web Apps **automatically injects** headers after user logs in:\n\n| Header | Value | Use |\n|--------|-------|-----|\n| `x-ms-client-principal-id` | `user-abc123` | Unique user ID |\n| `x-ms-client-principal-name` | `julia@example.com` | User's email |\n| `x-ms-client-principal` | Base64 claims | Full user object |\n\n**We only need the ID** for:\n- Fetching user's orders\n- Placing orders\n- Isolating chat history\n\n---\n\n### Free Authentication\n\nWith SWA, you get authentication **for free**:\n\n**No need to**:\n- âŒ Implement OAuth flow\n- âŒ Manage JWT tokens\n- âŒ Validate signatures\n- âŒ Store sessions\n\n**SWA handles everything!**\n\n---\n\n### Security Model\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Browser    â”‚  1. Click \"Login\"\nâ””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜\n       â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ SWA Auth Proxy   â”‚  2. Redirect to Azure AD\nâ””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n       â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Azure AD       â”‚  3. User authenticates\nâ””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n       â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ SWA Auth Proxy   â”‚  4. Generate session cookie\nâ””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n       â†“\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Backend API     â”‚  5. Extract userId from header\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Security properties**:\n1. **Header is trusted** - Only SWA can set it\n2. **Can't be spoofed** - User can't modify headers\n3. **Automatic validation** - SWA validates session cookie\n4. **No token management** - Cookies handled by browser\n\nUsers can only access **their own orders**! The userId flows through the entire system, ensuring proper data isolation."
    },
    {
      "title": "Agent API Best Practices",
      "description": "## Building Production Agent APIs âœ…\n\n---\n\n### Connection Management\n\n- [ ] **Open connections lazily** - Only when needed\n- [ ] **Close connections explicitly** - `await client.close()`\n- [ ] **Handle connection failures** - Retry with exponential backoff\n- [ ] **Set timeouts** - Don't wait forever for MCP server\n- [ ] **Pool connections** - Reuse for multiple requests (if possible)\n\n---\n\n### Streaming\n\n- [ ] **Use async generators** - Efficient memory usage\n- [ ] **Handle backpressure** - Slow clients shouldn't crash server\n- [ ] **Set appropriate headers** - `Content-Type: text/event-stream`\n- [ ] **Yield frequently** - Don't buffer too much\n- [ ] **Clean up on disconnect** - Cancel agent execution\n\n---\n\n### Error Handling\n\n- [ ] **Validate inputs early** - Before agent execution\n- [ ] **Catch all exceptions** - Never crash the function\n- [ ] **Return meaningful errors** - Help users debug\n- [ ] **Log errors properly** - Include context (userId, sessionId)\n- [ ] **Don't expose internals** - Sanitize error messages\n\n---\n\n### Performance\n\n- [ ] **Parallel operations** - Title generation, history loading\n- [ ] **Lazy loading** - Only fetch what's needed\n- [ ] **Caching** - Tool responses, chat history\n- [ ] **Timeouts** - Set max execution time\n- [ ] **Rate limiting** - Per user, per IP\n\n---\n\n### Security\n\n- [ ] **Validate userId** - Ensure authenticated\n- [ ] **Authorization checks** - User can only access their data\n- [ ] **Sanitize inputs** - Prevent injection attacks\n- [ ] **Don't log secrets** - No tokens, keys, passwords\n- [ ] **Set CORS properly** - Only allow your frontend\n\n---\n\n### ğŸ”¬ Advanced: Production Checklist\n\n- **Observability**\n- **Cost Tracking**\n- **Graceful Shutdown**"
    }
  ]
}