{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "1 - Introduction: Understanding AI Agents",
  "description": "Welcome! Get the big picture of how AI agents work by exploring a real-world burger ordering system. Perfect for all skill levels.",
  "isPrimary": true,
  "nextTour": "2 - Designing AI Agents",
  "steps": [
    {
      "title": "Welcome to AI Agent Development! ğŸ‰",
      "description": "## Welcome to the AI Agents CodeTour ğŸ‰\n\nThis guided tour will teach you how to **design, build, scale**, and **govern production-ready AI agents** that can interact with real-world systems using a practical example: A Burger ordering Agentic Assistant.\n\n### What Makes This Different?\n\nThis isn't just another chatbot. You'll learn how to build AI agents that:\n- **Take Actions**: Place orders, cancel requests, query databases\n- **Use Tools**: Connect to APIs through the Model Context Protocol (MCP)\n- **Stream Responses**: Provide real-time feedback to users\n- **Scale in Production**: Deploy on Azure serverless infrastructure\n\n---\n\n### What You'll Learn:\n\n- Burger Ordering System Architecture & data flow\n- LLM Configuration - System prompts & Agent personality \n- Exposing APIs to AI - Model Context Protocol (MCP)\n- LangChain.js implementation\n- The REST API the agent interacts with\n- Azure serverless deployment \n- Governance - Tracing, Monitoring & Observability\n- Chat UI integration\n\n---\n\n### Prerequisites\n\nâœ… You've cloned this repository and that the app is running. You can also interact with this agent via the command line! Check out packages/agent-cli for a terminal-based alternative to the web UI.\n\nIMPORTANT: **Wait for** \"ğŸš€ All services ready ğŸš€\" after starting the application\n\n---\n\n**Ready? Let's start by understanding what we are building!** â†’"
    },
    {
      "file": "README.md",
      "line": 28,
      "title": "The Burger Ordering Scenario",
      "description": "## The Scenario ğŸ”\n\nThis project demonstrates a **complete AI agent system** for burger ordering.\n\n### What Can This Agent Do?\n\n| Capability | Description | Try |\n|------------|-------------|-------------|\n| ğŸ” Browse Menu | View available burgers with descriptions | What burgers do you have?\n| ğŸ§… Explore Toppings | See what extras are available | What toppings are available?\n| ğŸ“ Place Orders | Create orders with customizations | Order me a bacon burger with extra cheese\n| ğŸ“Š Track Status | Check on pending orders | Show my recent orders\n| âŒ Cancel Orders | Remove unwanted orders | Cancel my last order\n\n---\n\n### Real-World Applications\n\nWhile this is a burger ordering system, the **same patterns** apply to:\n\nğŸ›’ **E-commerce**\n- Product discovery & recommendations\n- Cart management\n- Order placement & tracking\n\nğŸ’¼ **Business Automation**\n- Ticket management\n- Workflow automation\n- Data entry & retrieval\n\nğŸ¥ **Healthcare**\n- Appointment scheduling\n- Patient record queries\n- Prescription management\n\nğŸ¢ **Internal Tools**\n- IT helpdesk automation\n- HR request processing\n- Inventory management\n\n---\n\nThis implementation demonstrates:\n- **CRUD operations** through natural language\n- **User context** propagation (authentication)\n- **State management** (order status tracking)\n- **Data validation** (checking burger/topping IDs)\n- **Rate limiting** (max orders per user)\n- **Audit trails** (order history)\n\nAll patterns you'll need for production AI agents."
    },
    {
      "file": "README.md",
      "line": 52,
      "title": "The Three-Layer Architecture",
      "description": "## Three-Layer Architecture ğŸ—ï¸\n\nThe system is organized into three distinct layers:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    AGENT LAYER                              â”‚\nâ”‚                                                             â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚\nâ”‚  â”‚ Agent WebApp â”‚ â”€â”€â”€RESTâ”€â”€â”€â”€â–º â”‚ Agent API       â”‚          â”‚\nâ”‚  â”‚ (Chat UI)    â”‚ â—„â”€â”€Streamâ”€â”€â”€ â”‚ (LangChain.js)  â”‚          â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚\nâ”‚                                          â”‚                  â”‚\nâ”‚                                          â”‚ MCP Protocol     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                                           â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                     MCP LAYER            â–¼                  â”‚\nâ”‚                                                             â”‚\nâ”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚\nâ”‚              â”‚   Burger MCP Server           â”‚              â”‚\nâ”‚              â”‚   (Tool Definitions)          â”‚              â”‚\nâ”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚\nâ”‚                             â”‚                               â”‚\nâ”‚                             â”‚ HTTP REST                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                              â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                  BUSINESS LAYER  â–¼                          â”‚\nâ”‚                                                             â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚\nâ”‚  â”‚ Burger WebAppâ”‚ â—„â”€â”€â”€RESTâ”€â”€â”€â–º â”‚ Burger API      â”‚          â”‚\nâ”‚  â”‚ (Live Orders)â”‚              â”‚ (Business Logic)â”‚          â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚\nâ”‚                                         â”‚                   â”‚\nâ”‚                                         â–¼                   â”‚\nâ”‚                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚\nâ”‚                                  â”‚  Cosmos DB   â”‚           â”‚\nâ”‚                                  â”‚ (Data Store) â”‚           â”‚\nâ”‚                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n### Layer Breakdown\n\n#### 1ï¸âƒ£ Agent Layer (AI Interface)\n- **Agent WebApp**: Chat interface where users interact\n- **Agent API**: LangChain.js agent with reasoning and tool calling\n- **Technology**: Lit web components + Azure Functions\n\n#### 2ï¸âƒ£ MCP Layer (The Bridge)\n- **Burger MCP Server**: Translates between AI and business logic\n- **Role**: Exposes business API as AI-callable tools\n- **Technology**: Express.js + MCP SDK\n\n#### 3ï¸âƒ£ Business Layer (Core Logic)\n- **Burger API**: Standard REST API for burger operations\n- **Burger WebApp**: Visualization dashboard for live orders\n- **Database**: Cosmos DB for persistent storage\n- **Technology**: Azure Functions + Cosmos DB\n\n---\n\n### Whis this layering matters?\n\n**Separation of Concerns**:\n- AI logic separate from business logic\n- Can replace the AI layer without touching business code\n- Can test each layer independently (Testability)\n\n**Flexibility**:\n- Multiple AI agents can use the same MCP server (Reusability)\n- The business API can serve both AI and traditional clients\n- Easy to add new tools incrementally without modifying the agent\n- Control what the AI Agent can access (Security)\n---\n\nNotice the different protocols at each boundary:\n\n| Connection | Protocol | Why |\n|------------|----------|-----|\n| **UI â†’ Agent** | HTTP + Server-Sent Events | Standard web streaming |\n| **Agent â†’ MCP** | MCP over Streamable HTTP | Standardized tool discovery |\n| **MCP â†’ Business** | REST (JSON) | Existing API standard |\n\nThis means:\n- âœ… Your **existing REST APIs** work without modification\n- âœ… Standard **web technologies** throughout\n- âœ… Can swap **any layer** independently\n\n**Why this matters**: Each layer uses the **most appropriate** protocol for its purpose, but they all play nicely together."
    },
    {
      "file": "AGENTS.md",
      "line": 7,
      "title": "The Data Flow: User Request to Response",
      "description": "## Following a Request Through the System ğŸ”„\n\nLet's trace what happens when a user says: **\"Order me a cheeseburger\"**\n\n### Step-by-Step Flow\n\n```\n1. ğŸ‘¤ USER TYPES IN CHAT UI\n   \"Order me a cheeseburger\"\n   \n   â–¼ HTTP POST /api/chats/stream\n   \n2. ğŸŒ AGENT WEBAPP (packages/agent-webapp)\n   Sends: {\n     messages: [{role: \"user\", content: \"Order me a cheeseburger\"}],\n     context: {sessionId: \"abc-123\", userId: \"user-456\"}\n   }\n   \n   â–¼ HTTP POST with JSON body\n   \n3. ğŸ¤– AGENT API (packages/agent-api)\n   LangChain.js agent receives request\n   \n   LLM Reasoning:\n   \"User wants to order a cheeseburger. I need to:\n    1. Find the cheeseburger in the menu\n    2. Place an order for it\n   \n   First, I'll search the menu.\"\n   \n   â–¼ MCP Protocol: call get_burgers tool\n   \n4. ğŸ”Œ BURGER MCP SERVER (packages/burger-mcp)\n   Receives tool call: get_burgers()\n   \n   â–¼ HTTP GET /api/burgers\n   \n5. ğŸ” BURGER API (packages/burger-api)\n   Fetches burgers from Cosmos DB\n   Returns: [\n     {id: \"classic-cheese\", name: \"Classic Cheeseburger\", price: 8.99},\n     {id: \"bacon-cheese\", name: \"Bacon Cheeseburger\", price: 10.99},\n     ...\n   ]\n   \n   â–¼ JSON response back to MCP\n   \n6. ğŸ”Œ BURGER MCP SERVER\n   Formats response for AI: \"Found 5 burgers...\"\n   \n   â–¼ MCP Protocol response\n   \n7. ğŸ¤– AGENT API\n   LLM sees burger list, reasons:\n   \"Found the Classic Cheeseburger. Now I'll place the order.\"\n   \n   â–¼ MCP Protocol: call place_order tool\n   \n8. ğŸ”Œ BURGER MCP SERVER\n   Receives: place_order({\n     userId: \"user-456\",\n     items: [{burgerId: \"classic-cheese\", quantity: 1}]\n   })\n   \n   â–¼ HTTP POST /api/orders\n   \n9. ğŸ” BURGER API\n   - Validates user exists âœ…\n   - Validates burger ID exists âœ…\n   - Creates order in Cosmos DB\n   - Returns: {orderId: \"42\", status: \"pending\", total: 8.99}\n   \n   â–¼ JSON response\n   \n10. ğŸ”Œ BURGER MCP SERVER\n    Formats for AI: \"Order created successfully...\"\n    \n    â–¼ MCP Protocol response\n    \n11. ğŸ¤– AGENT API\n    LLM generates final response:\n    \"I've placed your order! Your Classic Cheeseburger is\n     order #42 and costs $8.99. ğŸ”\"\n    \n    â–¼ Streams response back (NDJSON)\n    \n12. ğŸŒ AGENT WEBAPP\n    Receives streaming chunks:\n    {delta: {content: \"I've\"}}\n    {delta: {content: \" placed\"}}\n    {delta: {content: \" your\"}}\n    ...\n    \n    â–¼ Renders in real-time\n    \n13. ğŸ‘¤ USER SEES RESPONSE\n    \"I've placed your order! Your Classic Cheeseburger is\n     order #42 and costs $8.99. ğŸ”\"\n```\n\n---\n\n### Key Observations\n\n1. **The LLM decides** which tools to call (get_burgers, then place_order)\n2. **Multiple steps** happen automatically (search, then order)\n3. **Streaming** makes it feel fast (user sees response forming)\n4. **User context** (userId) flows through the entire chain\n\n---"
    },
    {
      "title": "Traditional Chatbots vs AI Agents",
      "description": "## The Fundamental Difference ğŸ¤–\n\n### Traditional Chatbot: Just Talking\n\n```\nğŸ‘¤ User: \"Order me a cheeseburger\"\nğŸ’¬ Bot:  \"Sure! To place an order, please visit our\n        order page at www.example.com/order\"\n```\n\n**Problem**: The bot can't actually DO anything. It's just text generation.\n\n---\n\n### AI Agent: Taking Action\n\n```\nğŸ‘¤ User: \"Order me a cheeseburger\"\n\nğŸ¤– Agent thinks:\n   \"User wants to order. I should:\n    1. Check the menu (use get_burgers tool)\n    2. Find the cheeseburger\n    3. Place the order (use place_order tool)\"\n\nğŸ”§ Agent calls: get_burgers()\nğŸ”§ Agent calls: place_order({...})\n```\n\n**Result**: The order is actually placed in the system!\n\n---\n\nAI Agents are like giving an LLM **hands**. Instead of just talking about actions, they can:\n- Call APIs\n- Query databases  \n- Modify state\n- Integrate with existing systems\n\nThink of it as: **LLM (brain) + Tools (hands) = Agent**\n\n---\n\n### The Technical Shift\n\n| Aspect | Traditional Chatbot | AI Agent |\n|--------|---------------------|----------|\n| **Architecture** | Stateless text generation | Stateful reasoning loop |\n| **Output** | Text only | Tool calls + text |\n| **Integration** | None | API/system integration |\n| **Capabilities** | Information retrieval | Action execution |\n| **Complexity** | Simple | Multi-step reasoning |\n\nAgents use **tool calling** (also called function calling) where the LLM outputs structured data indicating which tool to call and with what parameters."
    },
    {
      "file": "README.md",
      "line": 161,
      "title": "The Available Tools (Agent Capabilities)",
      "description": "## MCP Tools: What the Agent Can Do ğŸ§°\n\nThe agent has access to **9 tools** via the Burger MCP Server:\n\n### Menu Exploration Tools\n\n| Tool | Purpose | Example Usage |\n|------|---------|---------------|\n| `get_burgers` | List all burgers in menu | \"What burgers do you have?\" |\n| `get_burger_by_id` | Get specific burger details | \"Tell me about the bacon burger\" |\n| `get_toppings` | List all available toppings | \"What toppings can I add?\" |\n| `get_topping_by_id` | Get specific topping info | \"How much is extra cheese?\" |\n| `get_topping_categories` | List topping categories | \"What types of toppings exist?\" |\n\n### Order Management Tools\n\n| Tool | Purpose | Example Usage |\n|------|---------|---------------|\n| `get_orders` | List user's orders (with filters) | \"Show my orders\" |\n| `get_order_by_id` | Get specific order details | \"What's in order #42?\" |\n| `place_order` | Create a new burger order | \"Order me a cheeseburger\" |\n| `delete_order_by_id` | Cancel a pending order | \"Cancel order #42\" |\n\n---\n\n### How the LLM Uses Tools\n\nThe LLM sees each tool with its **schema** (parameters, types, descriptions). For example:\n\n```typescript\n{\n  name: \"place_order\",\n  description: \"Place a new order with burgers\",\n  parameters: {\n    userId: {type: \"string\", required: true},\n    items: {\n      type: \"array\",\n      items: {\n        burgerId: {type: \"string\", required: true},\n        quantity: {type: \"number\", min: 1, required: true},\n        extraToppingIds: {type: \"array\", items: {type: \"string\"}}\n      }\n    },\n    nickname: {type: \"string\", optional: true}\n  }\n}\n```\n\nBased on this schema, when a user says **\"Order 2 bacon burgers with extra jalapeÃ±os\"**, the LLM:\n\n1. Understands it needs `place_order`\n2. Knows it needs to provide `userId`, `items` array\n3. Knows each item needs `burgerId`, `quantity`, and can have `extraToppingIds`\n4. Calls the tool with properly structured data\n\n---\n\n### Tool Schema Design\n\nWell-designed tool schemas are critical:\n\n**Good Schema**:\n```typescript\n{\n  name: \"place_order\",  // Clear verb\n  description: \"Place a new order with burgers (requires userId)\",  // Explains what AND requirements\n  parameters: {\n    userId: {description: \"ID of the user placing the order\"},  // Each param described\n    items: {description: \"List of items in the order\"}  // Arrays explained\n  }\n}\n```\n\n**Bad Schema**:\n```typescript\n{\n  name: \"order\",  // Vague\n  description: \"orders\",  // Useless\n  parameters: {userId: {}, items: {}}  // No descriptions\n}\n```\n\nThe LLM uses descriptions to understand:\n- **When** to use the tool\n- **What** each parameter means\n- **How** to structure the data\n\nWe'll explore schema design in detail in Tour 3!"
    },
    {
      "title": "What's Next: The Learning Path Ahead",
      "description": "## Tour 1 Complete! ğŸ‰\n\nYou now understand:\n- âœ… The difference between chatbots and AI agents\n- âœ… The three-layer architecture (Agent, MCP, Business)\n- âœ… How data flows through the system\n- âœ… What tools the agent can use\n\n---\n\nBefore moving to Tour 2, try experimenting:\n\n1. **Test the live app**\n   - Open http://localhost:4280\n   - Ask: \"What burgers do you have?\"\n   - Ask: \"Order me a bacon burger\"\n   - Watch the agent work!\n\n---\n\n## Your Next Steps\n\nğŸ¯ **Focus for Next Tour**:\nUnderstanding **system prompts** - the DNA of your AI agent!\n\n---\n\n**Ready to design your agent's personality?**  \nClick \"Next Tour\" or press `Ctrl+Right` â†’ **Tour 2: Designing AI Agents**"
    }
  ]
}